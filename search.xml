<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的一生最美好的场景就是遇见你]]></title>
    <url>%2F2017%2F11%2F13%2Fnana%2F</url>
    <content type="text"><![CDATA[+ 一直以来都在找那个对的人， 以为那个符合自己条条框框的人，就是那个对的人。直到真正遇到那个对的人，才会发现，那些所谓的要求，根本就是子虚乌有。哪怕是在一起什么事都不做，什么话都不说，十指相扣，一个眼神足以！ 我想，两个人在一起最好的状态就是不累人，不费神，不刻意，不用琢磨，更无须纠结，绝对占有，相对自由，不用担心害怕，因为你知道，对方真的不会走。没有哪两个人在一起就是合适的，总要经过一段时间的磨合，如果知道了对方的缺点，愿意去包容，还愿意在一起，这就是对的人吧！ 总是怕自己变得无趣，恨不得日夜翻书三百章，什么野史趣史都看上一道儿，什么甜话浑话俏皮话都为你学上一遭，恨不能把自己剖开给你看，浑身上下都抖擞着几句话，“我超有趣的” “我可有趣了” “你看看我吧”。 没有用照片记录我们在一起的时光，我想就记在这里吧，多久都不会丢。 很幸运能够于万千人海遇见你，然后相恋，我想，上天还是很眷顾我的，刚好遇见你，在我喜欢你的时候，你刚好也喜欢我。]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的接口]]></title>
    <url>%2F2017%2F11%2F08%2Finterface%2F</url>
    <content type="text"><![CDATA[+ 1.接口InterfaceInterface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量。interface类型默认是一个指针。Go 语言里有非常灵活的 接口 概念，通过它可以实现很多面向对象的特性。 1.1 Interface定义可以通过如下格式定义接口：12345type Namer interface &#123; Method1(param_list) return_type Method2(param_list) return_type ...&#125; 上面的 Namer 是一个 接口类型。（按照约定，只包含一个方法的）接口的名字由方法名加 [e]r 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头. 1.2 接口嵌套一个接口可以嵌套在另外的接口。即需要实现2个接口的方法。12345678910type Car interface &#123; NameGet() string Run(n int) Stop()&#125;type Used interface &#123; Car Cheap()&#125; 1.3 类型断言一个接口类型的变量varI中可以包含任何类型的值，必须有一种方式来检测它的动态类型，即运行时在变量中存储的值的实际类型,可以通过类型断言来实现。varI 必须是一个接口变量，否则编译器会报错。 12345if v, ok := varI.(T); ok &#123; // checked type assertion Process(v) return&#125;// varI is not of type T 通过switch判断其类型:12345678910switch t := areaIntf.(type) &#123;case *Square: fmt.Printf("Type Square %T with value %v\n", t, t)case *Circle: fmt.Printf("Type Circle %T with value %v\n", t, t)case nil: fmt.Printf("nil value: nothing to check?\n")default: fmt.Printf("Unexpected type %T\n", t)&#125; 1.4测试一个值是否实现了某个接口 类型断言中的一个特例：假定 v 是一个值，然后我们想测试它是否实现了 Stringer 接口， 可以这样做：1234567type Stringer interface &#123; String() string&#125;if sv, ok := v.(Stringer); ok &#123; fmt.Printf("v implements String(): %s\n", sv.String()) // note: sv, not v&#125; 1.5空接口 空接口或者最小接口 不包含任何方法，它对实现不做任何要求：123type Any interface &#123;&#125; 可以给一个空接口类型的变量 var val interface &#123;&#125; 赋任何类型的值 1.6 反射 反射是通过检查一个接口的值，变量首先被转换成空接口，函数签名：12func TypeOf(i interface&#123;&#125;) Typefunc ValueOf(i interface&#123;&#125;) Value 调用反射显示数据的类型12345678910package mainimport ( "fmt" "reflect")func main() &#123; var x float64 = 3.4 fmt.Println("type:", reflect.TypeOf(x)) 1.7 通过反射修改值在这里就需要使用Elem() 函数，这间接的使用指针：v = v.Elem()1234567891011121314151617181920package mainimport ( "fmt" "reflect")func main() &#123; var x float64 = 3.4 v := reflect.ValueOf(x) unaddressable value fmt.Println("settability of v:", v.CanSet()) v = reflect.ValueOf(&amp;x) fmt.Println("type of v:", v.Type()) fmt.Println("settability of v:", v.CanSet()) v = v.Elem() fmt.Println("The Elem of v is: ", v) fmt.Println("settability of v:", v.CanSet()) v.SetFloat(3.1415) fmt.Println(v.Interface()) fmt.Println(v)&#125; 通过上面的程序，就可以修改x的值了。]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的缓存库cache2go]]></title>
    <url>%2F2017%2F11%2F06%2FGolang%2F</url>
    <content type="text"><![CDATA[+ 1.cache2go简单介绍cache2go是一个并发安全，具有心跳功能的缓存库。核心功能只有3个文件。从中可以学习到，go语言中的锁、goroutine、map操作等。主要实现功能是对缓存项设置生命周期，可对一些过期的缓存进行删除（可设置缓存清理周期），也可以进行周期延拓，可以增加、删除、修改、更新缓存项，包含单条缓存和缓存表缓存。 2.cacheitem中源码分析Cacheitemu源码中主要介绍单条缓存，包含创建新的缓存条目，创建时间，上次访问时间，以及被访问的频率。从下图中的从结构体中我们可以看到key与data都是interface{}类型，即可以接收任意类型，但是建议key为可比较的类型。 lifeSpan time.Duration 可设置生命周期，以及创建时间，访问次数等记录，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package cache2goimport ( "sync" "time")type CacheItem struct &#123; sync.RWMutex // 缓存项的key key interface&#123;&#125; // 缓存项的值 data interface&#123;&#125; // 缓存项的生命期 lifeSpan time.Duration // 创建时间戳 createdOn time.Time // 上次访问的时间戳 accessedOn time.Time // 被访问的次数 accessCount int64 // 缓存项被删除时的回调函数(删之前执行) aboutToExpire func(key interface&#123;&#125;)&#125;//NewCacheItem return a newly created CacheItem.//Parameter key is the item's cache-key.//Parameter lifeSpan determines after which time period without an access the item//will get removed from the cache//Parameter data is the item's valuefunc NewCacheItem(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; t := time.Now() return &amp;CacheItem&#123; key: key, lifeSpan: lifeSpan, createdOn: t, accessedOn: t, accessCount: 0, aboutToExpire: nil, data: data, &#125;&#125;//keepAlive marks an item to be kept for another expireDuration period//KeepAlive将要保留的项目标记为另一个到期时间func (item *CacheItem) KeepAlive() &#123; item.Lock() defer item.Unlock() item.accessedOn = time.Now() item.accessCount++&#125;//LifeSpan returns this item's expieation duration//LifeSpan返回此项目的到期时间func (item *CacheItem) LifeSpan() time.Duration &#123; return item.lifeSpan&#125;//AccessedOn returns when this item was last accessed.//AccessedOn返回上次访问此项目时间func (item *CacheItem) AccessedOn() time.Time &#123; item.RLock() defer item.RLock() return item.accessedOn&#125;//CreatedOn returns when this item was added to the cache.//CreatedOn将此项目添加到缓存时返回 返回添加时间func (item *CacheItem) CreatedOn() time.Time &#123; return item.createdOn&#125;//AccessCount returns how often this item has been accessed.//AccessCount返回此项目被访问的频率func (item *CacheItem) AccessCount() int64 &#123; item.RLock() defer item.RUnlock() return item.accessCount&#125;//Key returns the key of this cached itemfunc (item *CacheItem) Key() interface&#123;&#125; &#123; return item.key&#125;//Data returns the value of this cached item.func (item *CacheItem) Data() interface&#123;&#125; &#123; return item.data&#125;//SetAboutToExpireCallback configures a callback, which will be called right//before the item is about to be removed from the cache.// SetAboutToExpireCallback配置一个回调函数，这将被调用//在项目即将从缓存中删除之前。func (item *CacheItem) SetAboutToExpireCallback(f func(interface&#123;&#125;)) &#123; item.Lock() defer item.Unlock() item.aboutToExpire = f&#125; 3.cachetable中源码分析CacheTable结构如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346package cache2goimport ( "log" "sort" "sync" "time")// CacheTable is a table within the cachetype CacheTable struct &#123; sync.RWMutex //读写锁 // 缓存表名 name string // 缓存项 items map[interface&#123;&#125;]*CacheItem // 触发缓存清理的定时器 cleanupTimer *time.Timer // 缓存清理周期 cleanupInterval time.Duration // 该缓存表的日志 logger *log.Logger // 获取一个不存在的缓存项时的回调函数 loadData func(key interface&#123;&#125;, args ...interface&#123;&#125;) *CacheItem //向缓存表增加缓存项时的回调函数 addedItem func(item *CacheItem) // 从缓存表删除一个缓存项时的回调函数 aboutToDeleteItem func(item *CacheItem)&#125;// Count returns how many items are currently stored in the cache.//返回缓存中存储有多少项func (table *CacheTable) Count() int &#123; //允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作 table.RLock() defer table.RUnlock() return len(table.items)&#125;// Foreach all items 所有项目func (table *CacheTable) Foreach(trans func(key interface&#123;&#125;, item *CacheItem)) &#123; table.RLock() defer table.RUnlock() for k, v := range table.items &#123; trans(k, v) &#125;&#125;// SetDataLoader configures a data-loader callback, which will be called when// trying to access a non-existing key. The key and 0...n additional arguments// are passed to the callback function.// SetDataLoader配置一个数据加载的回调，当尝试去请求一个不存在的key的时候调用func (table *CacheTable) SetDataLoader(f func(interface&#123;&#125;, ...interface&#123;&#125;) *CacheItem) &#123; table.Lock() defer table.Unlock() table.loadData = f&#125;// SetAddedItemCallback configures a callback, which will be called every time// a new item is added to the cache.//配置一个回调，当向缓存中添加项目时每次都会被调用。func (table *CacheTable) SetAddedItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.addedItem = f&#125;// SetAboutToDeleteItemCallback configures a callback, which will be called// every time an item is about to be removed from the cache.//配置一个回调，当一个项目从缓存中删除时每次都会被调用。func (table *CacheTable) SetAboutToDeleteItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.aboutToDeleteItem = f&#125;// SetLogger sets the logger to be used by this cache table.//设置缓存表需要使用的logfunc (table *CacheTable) SetLogger(logger *log.Logger) &#123; table.Lock() defer table.Unlock() table.logger = logger&#125;// Expiration check loop, triggered by a self-adjusting timer.//缓存过期检查，通过一个定时器触发func (table *CacheTable) expirationCheck() &#123; table.Lock() if table.cleanupTimer != nil &#123; table.cleanupTimer.Stop() &#125; if table.cleanupInterval &gt; 0 &#123; table.log("Expiration check triggered after", table.cleanupInterval, "for table", table.name) &#125; else &#123; table.log("Expiration check installed for table", table.name) &#125; // To be more accurate with timers, we would need to update 'now' on every // loop iteration. Not sure it's really efficient though. // To be more accurate with timers, we would need to update 'now' on every // loop iteration. Not sure it's really efficient though. //为了定时器准确，我们需要在每一个循环中更新‘now’，不确定是否是有效的。 now := time.Now() smallestDuration := 0 * time.Second for key, item := range table.items &#123; // Cache values so we don't keep blocking the mutex. item.RLock() lifeSpan := item.lifeSpan accessedOn := item.accessedOn item.RUnlock() if lifeSpan == 0 &#123; continue //等于0，永久有效 &#125; if now.Sub(accessedOn) &gt;= lifeSpan &#123; // Item has excessed its lifespan.项目已经超过了项目周期 table.deleteInternal(key) &#125; else &#123; // Find the item chronologically closest to its end-of-lifespan. //查找最靠近结束生命周期的项目 if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123; smallestDuration = lifeSpan - now.Sub(accessedOn) &#125; &#125; &#125; // Setup the interval for the next cleanup run. //为下次清理设置间隔 table.cleanupInterval = smallestDuration if smallestDuration &gt; 0 &#123; table.cleanupTimer = time.AfterFunc(smallestDuration, func() &#123; go table.expirationCheck() &#125;) &#125; table.Unlock()&#125;func (table *CacheTable) addInternal(item *CacheItem) &#123; // Careful: do not run this method unless the table-mutex is locked! // It will unlock it for the caller before running the callbacks and checks table.log("Adding item with key", item.key, "and lifespan of", item.lifeSpan, "to table", table.name) table.items[item.key] = item // Cache values so we don't keep blocking the mutex. expDur := table.cleanupInterval addedItem := table.addedItem table.Unlock() // Trigger callback after adding an item to cache. if addedItem != nil &#123; addedItem(item) &#125; // If we haven't set up any expiration check timer or found a more imminent item. if item.lifeSpan &gt; 0 &amp;&amp; (expDur == 0 || item.lifeSpan &lt; expDur) &#123; table.expirationCheck() &#125;&#125;// Add adds a key/value pair to the cache.// Parameter key is the item's cache-key.// Parameter lifeSpan determines after which time period without an access the item// will get removed from the cache.// Parameter data is the item's value.//添加键值对到缓存中//参数key是cache-key。//参数lifeSpan（生命周期），确定在没有访问该项目的时间段后将从缓存中移除。//参数data是项目中的值。func (table *CacheTable) Add(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; item := NewCacheItem(key, lifeSpan, data) //调用 // Add item to cache. table.Lock() table.addInternal(item) return item&#125;func (table *CacheTable) deleteInternal(key interface&#123;&#125;) (*CacheItem, error) &#123; r, ok := table.items[key] if !ok &#123; return nil, ErrKeyNotFound &#125; // Cache value so we don't keep blocking the mutex. aboutToDeleteItem := table.aboutToDeleteItem table.Unlock() // Trigger callbacks before deleting an item from cache. if aboutToDeleteItem != nil &#123; aboutToDeleteItem(r) &#125; r.RLock() defer r.RUnlock() if r.aboutToExpire != nil &#123; r.aboutToExpire(key) &#125; table.Lock() table.log("Deleting item with key", key, "created on", r.createdOn, "and hit", r.accessCount, "times from table", table.name) delete(table.items, key) return r, nil&#125;// Delete an item from the cache.func (table *CacheTable) Delete(key interface&#123;&#125;) (*CacheItem, error) &#123; table.Lock() defer table.Unlock() return table.deleteInternal(key)&#125;// Exists returns whether an item exists in the cache. Unlike the Value method// Exists neither tries to fetch data via the loadData callback nor does it// keep the item alive in the cache.//返回项目是否在缓存中，不像这个数据方法，既不尝试渠道数据本地的回调也不保证//项目在缓存中是否是存活的。func (table *CacheTable) Exists(key interface&#123;&#125;) bool &#123; table.RLock() defer table.RUnlock() _, ok := table.items[key] return ok&#125;// NotFoundAdd tests whether an item not found in the cache. Unlike the Exists// method this also adds data if they key could not be found.//测试是否一个项目不存在在缓存中，不像已经存在的方法，当key不存在时依旧添加。func (table *CacheTable) NotFoundAdd(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) bool &#123; table.Lock() if _, ok := table.items[key]; ok &#123; table.Unlock() return false &#125; item := NewCacheItem(key, lifeSpan, data) table.addInternal(item) return true&#125;// Value returns an item from the cache and marks it to be kept alive. You can// pass additional arguments to your DataLoader callback function.//从缓存中返回一个被标记的并保持活性的值，你可以传附件的参数到DATaLoader回调函数func (table *CacheTable) Value(key interface&#123;&#125;, args ...interface&#123;&#125;) (*CacheItem, error) &#123; table.RLock() r, ok := table.items[key] loadData := table.loadData table.RUnlock() if ok &#123; // Update access counter and timestamp. r.KeepAlive() return r, nil &#125; // Item doesn't exist in cache. Try and fetch it with a data-loader. if loadData != nil &#123; item := loadData(key, args...) if item != nil &#123; table.Add(key, item.lifeSpan, item.data) return item, nil &#125; return nil, ErrKeyNotFoundOrLoadable &#125; return nil, ErrKeyNotFound&#125;// Flush deletes all items from this cache table.func (table *CacheTable) Flush() &#123; table.Lock() defer table.Unlock() table.log("Flushing table", table.name) table.items = make(map[interface&#123;&#125;]*CacheItem) table.cleanupInterval = 0 if table.cleanupTimer != nil &#123; table.cleanupTimer.Stop() &#125;&#125;// CacheItemPair maps key to access countertype CacheItemPair struct &#123; Key interface&#123;&#125; AccessCount int64&#125;// CacheItemPairList is a slice of CacheIemPairs that implements sort.// Interface to sort by AccessCount.//CacheItemPairList时CacheItemPairs的一个排序后的切片，interface依据请求次数排序。type CacheItemPairList []CacheItemPairfunc (p CacheItemPairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p CacheItemPairList) Len() int &#123; return len(p) &#125;func (p CacheItemPairList) Less(i, j int) bool &#123; return p[i].AccessCount &gt; p[j].AccessCount &#125;// MostAccessed returns the most accessed items in this cache table//返回缓存表中被访问最多的项目func (table *CacheTable) MostAccessed(count int64) []*CacheItem &#123; table.RLock() defer table.RUnlock() p := make(CacheItemPairList, len(table.items)) i := 0 for k, v := range table.items &#123; p[i] = CacheItemPair&#123;k, v.accessCount&#125; i++ &#125; sort.Sort(p) var r []*CacheItem c := int64(0) for _, v := range p &#123; if c &gt;= count &#123; break &#125; item, ok := table.items[v.Key] if ok &#123; r = append(r, item) &#125; c++ &#125; return r&#125;// Internal logging method for convenience.func (table *CacheTable) log(v ...interface&#123;&#125;) &#123; if table.logger == nil &#123; return &#125; table.logger.Println(v)&#125; 该结构体中关于其中的锁和sync，当变量被一个线程改变时(临界区)，我们为它上锁，直到这个线程执行完成并解锁后，其他线程才能访问它。sync.Mutex 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。在sync包中还有一个 RWMutex 锁：它能通过 RLock()来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 Lock() 将和普通的 Mutex 作用相同。包中还有一个方便的 Once 类型变量的方法 once.Do(call)，这个方法确保被调用函数只能被调用一次。锁的目的就是几个线程访问同一个变量时，无法预知变量被不同线程修改的顺序，确保一次只有一个线程访问。从结构体可以看出缓存表就是由一个值类型为缓存项的map以及一些附加属性组成：name用来唯一标识一个缓存表，在创建缓存表时指定。items是一个存储缓存项的map。cleanupTimer和cleanupInterval来控制多久更新一次缓存。相比于缓存项，缓存表多了一些回调函数。缓存表指定的回调函数作用于缓存表内的所有缓存项，而缓存项指定的回调函数仅对单条缓存有效。缓存表提供了缓存常见的操作方法：增：Add，NotFoundAdd删：Delete查：Value是否存在：Exists缓存总数：Count缓存刷新：Flush缓存遍历：Foreach回调函数设置：SetAboutToDeleteItemCallba，SetAddedItemCallback，SetDataLoader访问最多的前几个缓存项：MostAccessed为了提供访问最多的前几个缓存项，cache2go又定义了CacheItemPair和CacheItemPairList。CacheItemPair有缓存的key和AccessCount组成，而CacheItemPairList则是CacheItemPair组成的Slice，且实现了Sort接口。 4.缓存12345678910111213141516171819202122232425262728293031323334package cache2goimport "sync"var ( cache = make(map[string]*CacheTable) mutex sync.RWMutex)//Cache returns the exiting cache table with given name or creates a new one//if the table does not exist yet.//返回现有的缓存表与给定的名称，如果表不存在创基一个新的func Cache(table string) *CacheTable &#123; //读取时加了一个读锁Rlock，读完之后解锁Runlock mutex.RLock() t, ok := cache[table] mutex.RUnlock() //ok，用来判断cache的map是否存在，不存在就创建，存在就返回，返回的是CacheTable的地址 if !ok &#123; mutex.Lock() t, ok = cache[table] //Double check wether the table exists or not if !ok &#123; t = &amp;CacheTable&#123; name: table, items: make(map[interface&#123;&#125;]*CacheItem), &#125; cache[table] = t &#125; mutex.Unlock() &#125; return t&#125; 使用cache2go时，我们第一步一般都是调用上面的Cache函数创建缓存，该函数会检查一个全局变量cache（该变量是一个map，其值类型为CacheTable，key是缓存表的名字），如果该map中已经有名字为table的缓存表，就返回该缓存表；否则就创建。该函数返回缓存表的指针，即CacheTable。也就是说在cache2go中，缓存表就代表一个缓存，而我们可以创建多个不同名字的缓存，存储在全局变量cache中。]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的错误处理]]></title>
    <url>%2F2017%2F11%2F05%2Ferror%2F</url>
    <content type="text"><![CDATA[+ 1.错误处理Go 有一个预先定义的 error 接口类型123type error interface &#123; Error() string&#125; 任何时你需要一个新的错误类型时，都可以用 error包的 errors.New 函数接收合适的错误信息来创建1err := errors.New(“math - square root of negative number”) 用fmt创建错误对象123if f &lt; 0 &#123; return 0, fmt.Errorf("math: square root of negative number %g", f)&#125; 通常想要返回包含错误参数的更有信息量的字符串，例如：可以用 fmt.Errorf() 来实现：它和 fmt.Printf() 完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。 2.运行时异常和 panic当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时panicpanic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。123456789package mainimport "fmt"func main() &#123; fmt.Println("Starting the program") panic("A severe error occurred: stopping the program!") fmt.Println("Ending the program")&#125; 当发生错误必须中止程序时，panic可以用于错误处理模式：123if err != nil &#123; panic("ERROR occurred:" + err.Error())&#125; 在多层嵌套的函数调用中调用panic可以马上中止当前函数的执行,所有的defer语句都会保证执行并把控制权交还给接收到panic的函数调用者。 3.从 panic 中恢复（Recover）这个（recover）内建函数被用于从panic或错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。 recover只能在defer修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用recover会返回nil，且没有其它效果。 下面例子中的 protect 函数调用函数参数 g 来保护调用者防止从 g 中抛出的运行时 panic，并展示 panic 中的信息：1234567891011func protect(g func()) &#123; defer func() &#123; log.Println("done") // Println executes normally even if there is a panic if err := recover(); err != nil &#123; log.Printf("run time panic: %v", err) &#125; &#125;() log.Println("start") g() // possible runtime-error&#125; 完整示例：12345678910111213141516171819202122232425package mainimport ( "fmt")func badCall() &#123; panic("bad end")&#125;func test() &#123; defer func() &#123; if e := recover(); e != nil &#123; fmt.Printf("Panicing %s\r\n", e) &#125; &#125;() badCall() fmt.Printf("After bad call\r\n") // &lt;-- wordt niet bereikt&#125;func main() &#123; fmt.Printf("Calling test\r\n") test() fmt.Printf("Test completed\r\n")&#125; 首先，执行main函数，先输出Calling test,然后调用test函数，首先程序进入panic，然后执行defer语句，调用recover，恢复程序执行，输出程序panic的原因，最后执行Testcompleted. 4.自定义包中的错误处理和 panicking1）在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic()2）向包的调用者返回错误值（而不是 panic）。在包内部，特别是在非导出函数中有很深层次的嵌套调用时，对主调函数来说用 panic 来表示应该被翻译成错误的错误场景是很有用的（并且提高了代码可读性）。 5.一种用闭包处理错误的模式每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复的代码。假设所有的函数都有这样的签名：1func f(a type1, b type2) 给这个类型定义一个名字：1fType1 = func f(a type1, b type2) 使用两个辅助函数：1)check：这是用来检查是否有错误和 panic 发生的函数：1func check(err error) &#123; if err != nil &#123; panic(err) &#125; &#125; 2)errorhandler：这是一个包装函数。接收一个fType1类型的函数fn并返回一个调用fn的函数。里面就包含有defer/recover机制。12345678910func errorHandler(fn fType1) fType1 &#123; return func(a type1, b type2) &#123; defer func() &#123; if err, ok := recover().(error); ok &#123; log.Printf(“run time panic: %v”, err) &#125; &#125;() fn(a, b) &#125;&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[013 努力把生活过成自己喜欢的模样]]></title>
    <url>%2F2017%2F11%2F05%2F13%2F</url>
    <content type="text"><![CDATA[+ 我们总会羡慕别人的生活，总觉得别人把生活是自己想要的那种生活方式，看到别人朋友圈晒出去哪玩，最近又做了什么，自己心里也会想这个我也会啊，我也可以的，可是，最终，我们都没有完成，还是一边在拖延中度过，一边在后悔自己不该拖延中度过。我们都可以改变自己适应身边的环境，也可以改变自己适应成功，那么我想我们应该也可以改掉自己拖延的毛病。 今天出去爬山了，去了半山，感觉还是挺有意思的，虽然这边的山普遍都不高，虽然不能说今天收获到了什么，总之，可以散散心，将自己的状态调整到最佳看，面对周一和新的挑战。 慢慢地成长，把生活过程自己想要的模样。我觉得，人生活就是为了让自己有愉悦感，幸福感，成就感。这些东西说难也难，说简单也很简单。每个人理解的方式可能会有所不同，但重要的是一定要有希望，要热爱，和不放弃。]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounters</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的控制流程]]></title>
    <url>%2F2017%2F11%2F02%2Felse%2F</url>
    <content type="text"><![CDATA[+ 1.条件语句if是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。123if condition &#123; // do something&#125; 两个分支：12345 if condition &#123; // do something&#125; else &#123; // do something&#125; 多个分支：1234567if condition1 &#123; // do something&#125; else if condition2 &#123; // do something else&#125;else &#123; // catch-all or default&#125; 简单示例：12345678910package mainimport "fmt"func main() &#123; bool1 := true if bool1 &#123; fmt.Printf("The value is true\n") &#125; else &#123; fmt.Printf("The value is false\n") &#125;&#125; 关于条件语句，需要注意以下几点：  条件语句不需要使用括号将条件包含起来()； 无论语句体内有几条语句，花括号{}都是必须存在的； 左花括号{必须与if或者else处于同一行；  在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔；  在有返回值的函数中，不允许将“终的”return语句包含在if…else…结构中,否则会编译失败： function ends without a return statement。 失败的原因在于，Go编译器无法找到终止该函数的return语句。 1.1测试多返回值函数的错误习惯用法123456value, err := pack1.Function1(param1)if err != nil &#123; fmt.Printf("An error occured in pack1.Function1 with parameter %v", param1) return err&#125;// 未发生错误，继续执行： 如果在main函数中执行这段代码，程序会直接停止运行。如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数：1234if err != nil &#123; fmt.Printf("Program stopping with error %v", err) os.Exit(1)&#125; 2.switch结构用法：12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。简单示例：12345678910111213141516package mainimport "fmt"func main() &#123; var num1 int = 100 switch num1 &#123; case 98, 99: fmt.Println("It's equal to 98") case 100: fmt.Println("It's equal to 100") default: fmt.Println("It's not equal to 98 or 100") &#125;&#125; 3.for语句基本形式： 1for 初始化语句; 条件语句; 修饰语句 &#123;&#125; for 循环嵌套起来：12345for i:=0; i&lt;5; i++ &#123; for j:=0; j&lt;10; j++ &#123; println(j) &#125;&#125; 3.1基于条件判断的迭代123456789101112package mainimport "fmt"func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf("The variable i is now: %d\n", i) &#125;&#125; 3.2 for-range 结构12345678910111213package mainimport "fmt"func main() &#123; str := "Go is a beautiful language!" fmt.Printf("The length of str is: %d\n", len(str)) for pos, char := range str &#123; fmt.Printf("Character on position %d is: %c \n", pos, char) &#125; fmt.Println()&#125; 首先输出字符串的长度，然后通过for-range，遍历每个字符，然后分别输出每个字符。（通过键值对的组合） 4.Break和continuebreak会跳出当前的循环： 1234567for &#123; i = i - 1 fmt.Printf("The variable i is now: %d\n", i) if i &lt; 0 &#123; break &#125;&#125; 每次迭代都会对条件进行检查（i &lt; 0），以此判断是否需要停止循环。如果退出条件满足，则使用 break 语句退出循环。break 的作用范围是该循环的最内部循环体。 关键字continue忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件。 1234567891011package mainfunc main() &#123; for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; continue &#125; print(i) print(" ") &#125;&#125; 5.标签与gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母continue: 1234567891011121314151617package mainimport "fmt"func main() &#123;LABEL1: for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf("i is: %d, and j is: %d\n", i, j) &#125; &#125;&#125; continue语句指向LABEL1，当执行到该语句的时候，就会跳转到LABEL1标签的位置。当 j==4和j==5的时候，没有任何输出：标签的作用对象为外部循环。goto: 123456789101112package mainfunc main() &#123; i:=0 HERE: print(i) i++ if i==5 &#123; return &#125; goto HERE&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012 一个人也要生活的很精致]]></title>
    <url>%2F2017%2F11%2F02%2F012%2F</url>
    <content type="text"><![CDATA[+ 在我们的生命里，会遇到许多人，也会很成功的错过很多人，成为彼此生命中的过客，直到最后那个不离开的人，才会是我们生命中最重要的人。我想，总有一天，我们都会遇到那个对的人，在此之前，我们都应该让自己更加完美，以最美的姿态迎接那个对的人。 随手拍——图文无关 荷西问三毛：你想嫁个什么样的人？三毛说：看的顺眼的，千万富翁也嫁；看不顺眼的，亿万富翁也嫁。荷西：说来说去还是想嫁个有钱的。三毛看了荷西一眼：也有例外。那你要是嫁给我呢？荷西问道。三毛叹了口气：要是你的话，只要够吃饭的钱就够了。那你吃得多吗？荷西问。不多不多，以后还可以少吃点。我们都会遇到那么一个人，遇到之后，原来那些条条框框的标准，都会一条不剩，爱的仅仅是那个人，我们都会渴望柯西和三毛爱情，简简单单，一个眼神就足以读懂对方，希望我们都会尽早遇到那个人吧。 随手拍——图文无关 在这个陌生的城市中，希望我们不要迷失自己，一个人也要生活的很精致，没有遇到那个对的人之前，努力让自己更加完美一点。喜欢阅读，虽然不会立刻感觉都有多大用处，但是我相信，量变会引起质变的，这些都将是我的财富。偶尔周末出去走走，虽然说也没有什么收获，但也可以让自己散散心，以最好的状态面对新的一周，面对工作和学习。不要老是羡慕别人的生活，只要我们愿意付出，我们自己的生活也会充满诗情画意。无论你在哪，你在干什么，请务必记得，一个人也要生活的很精致！]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang实现简单的聊天室]]></title>
    <url>%2F2017%2F10%2F31%2Fchat%2F</url>
    <content type="text"><![CDATA[+ 首先，要实现聊天，就要有一个服务器接收发送到的信息，还有一个客户端向服务器发送信息，所以有两部分代码，一部分是客户端，另一部分是服务端。 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( "fmt" "net" "os")//通道var clients []net.Connfunc main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port data = make([]byte, 1024) ) fmt.Println("Initiating server...") lis, err := net.Listen("tcp", remote) defer lis.Close() if err != nil &#123; fmt.Printf("Error when listen: %s, Err: %s\n", remote, err) os.Exit(-1) &#125; for &#123; var res string conn, err := lis.Accept() if err != nil &#123; fmt.Println("Error accepting client: ", err.Error()) os.Exit(0) &#125; clients = append(clients, conn) go func(con net.Conn) &#123; fmt.Println("New connection: ", con.RemoteAddr()) // Get client's name length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %v quit.\n", con.RemoteAddr()) con.Close() disconnect(con, con.RemoteAddr().String()) return &#125; name := string(data[:length]) comeStr := name + " entered the room." notify(con, comeStr) // Begin recieve message from client for &#123; length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %s quit.\n", name) con.Close() disconnect(con, name) return &#125; res = string(data[:length]) sprdMsg := name + " said: " + res fmt.Println(sprdMsg) res = "You said:" + res con.Write([]byte(res)) notify(con, sprdMsg) &#125; &#125;(conn) &#125;&#125;//服务端收到消息后需要通知各个客户端func notify(conn net.Conn, msg string) &#123; for _, con := range clients &#123; if con.RemoteAddr() != conn.RemoteAddr() &#123; con.Write([]byte(msg)) &#125; &#125;&#125;//当有人离开聊天室时，通知所有的用户。func disconnect(conn net.Conn, name string) &#123; for index, con := range clients &#123; if con.RemoteAddr() == conn.RemoteAddr() &#123; disMsg := name + " has left the room." fmt.Println(disMsg) clients = append(clients[:index], clients[index+1:]...) notify(conn, disMsg) &#125; &#125;&#125; 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( "bufio" "fmt" "net" "os")var writeStr, readStr = make([]byte, 1024), make([]byte, 1024)func main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port reader = bufio.NewReader(os.Stdin) ) con, err := net.Dial("tcp", remote) defer con.Close() if err != nil &#123; fmt.Println("Server not found.") os.Exit(-1) &#125; fmt.Println("Connection OK.") fmt.Printf("Enter your name: ") fmt.Scanf("%s", &amp;writeStr) in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; fmt.Println("Now begin to talk!") go read(con) for &#123; writeStr, _, _ = reader.ReadLine() if string(writeStr) == "quit" &#123; fmt.Println("Communication terminated.") os.Exit(1) &#125; in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; &#125;&#125;func read(conn net.Conn) &#123; for &#123; length, err := conn.Read(readStr) if err != nil &#123; fmt.Printf("Error when read from server. Error:%s\n", err) os.Exit(0) &#125; fmt.Println(string(readStr[:length])) &#125;&#125; 结果见下图先开启服务端 然后开启服务端]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011 始于颜值 陷于才华 忠于人品]]></title>
    <url>%2F2017%2F10%2F31%2F011onlyyou%2F</url>
    <content type="text"><![CDATA[+ 始于心动，终于白首，初于花雨，至于天荒！ 有人说，爱一个人始于颜值，陷于才华，终于人品。在我看来，不过简单的一句：始于心动，终于心安。心动于颜值，相由心生，亦归结为品格；心动于才华，亦是如此。终于心安，唯真爱方能长久，唯深爱归于平静。愿你的枕边身边一直都是她，从心动到心安，从青丝到白发，从荆棘到百花，从校服到婚纱，一直都是他。 想说陪我走走吧，去哪都行，只要你愿意！想说带你去吃饭，你想吃什么我都给你做，新学的红烧排骨很不错，只要你愿意！想说聊聊天吧，虽然我看了好多套路却一套都没学会，只要你愿意！想说想你了，无论是忙还是闲。 虽然遇到一个自己喜欢和喜欢自己的人很难，但是总该争取的还是要好好争取，望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。 我想，迟早会遇到那个人吧。]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的数组]]></title>
    <url>%2F2017%2F10%2F30%2Farray%2F</url>
    <content type="text"><![CDATA[+ 1.数组1.1常见声明：1234[32]byte //长度32的字节数组[2*N] struct &#123;x, y int32&#125; //复杂类型的数组[1000]*float64 //指针数组[3][5]int //int类型的二维数组 1.2元素访问：通过数组下标访问元素。123for i: = 0; i &lt; len(array): i++ &#123;fmt.Println("Element",i,"of array is",array[i])&#125; Go语言还提供了一个关键字range，用于便捷地遍历容器中的元素。123for i, v := range array &#123; fmt.Println("Array element[", i, "]=", v)&#125; 1.3值类型在Go语言中数组是一个值类型，所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。 如果将数组作为函数的参数类型，则在函数调用时参数将发生复制。 1234567891011package mainimport "fmt"func modify(array [10]int) &#123; array[0] = 10 // 试图修改数组的第一个元素 fmt.Println("In modify(), array values:", array)&#125;func main() &#123; array := [5]int&#123;1,2,3,4,5&#125; // 定义并初始化一个数组 modify(array) // 传递给一个函数，并试图在函数体内修改这个数组内容 fmt.Println("In main(), array values:", array)&#125; 2.数组切片2.1创建数组切片123mySlice1 := make([]int, 5)mySlice2 := make([]int, 5, 10)mySlice3 := []int&#123;1, 2, 3, 4, 5&#125; 2.2元素遍历通过for循环：123for i := 0; i &lt;len(mySlice); i++ &#123; fmt.Println("mySlice[", i, "] =", mySlice[i])&#125; 使用range关键字遍历123for i, v := range mySlice &#123; fmt.Println("mySlice[", i, "] =", v)&#125; 2.3动态增加元素通过内置函数获取切片长度和容量1234567package mainimport "fmt"func main() &#123; mySlice := make([]int, 5, 10) fmt.Println("len(mySlice):", len(mySlice)) fmt.Println("cap(mySlice):", cap(mySlice))&#125; 通过append函数向数组切片中追加元素1234mySlice = append(mySlice, 1, 2, 3)mySlice2 := []int&#123;8, 9, 10&#125;// 给mySlice后面添加另一个数组切片mySlice = append(mySlice, mySlice2...) 2.4基于数组切片创建数组切片12oldSlice := []int&#123;1, 2, 3, 4, 5&#125;newSlice := oldSlice[:3] // 基于oldSlice的前3个元素构建新数组切片 2.5内容复制1234slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 2.6代码示例1234567891011121314151617package mainimport "fmt"func main() &#123; // 先定义一个数组 var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; // 基于数组创建一个数组切片 var mySlice []int = myArray[:5] fmt.Println("Elements of myArray: ") for _, v := range myArray &#123; fmt.Print(v, " ") &#125; fmt.Println("\nElements of mySlice: ") for _, v := range mySlice &#123; fmt.Print(v, " ") &#125; fmt.Println()&#125; 3.map3.1代码示例123456789101112131415161718192021222324package mainimport "fmt"// PersonInfo是一个包含个人详细信息的类型type PersonInfo struct &#123; ID string Name string Address string&#125;func main() &#123;var personDB map[string] PersonInfo personDB = make(map[string] PersonInfo) // 往这个map里插入几条数据 personDB["12345"] = PersonInfo&#123;"12345", "Tom", "Room 203,..."&#125; personDB["1"] = PersonInfo&#123;"1", "Jack", "Room 101,..."&#125; // 从这个map查找键为"1234"的信息 person, ok := personDB["1234"] // ok是一个返回的bool型，返回true表示找到了对应的数据 if ok &#123; fmt.Println("Found person", person.Name, "with ID 1234.") &#125; else &#123; fmt.Println("Did not find person with ID 1234.") &#125;&#125; 3.2变量声明var myMap map[string] PersonInfo 3.3创建123456// PersonInfohi一个结构体myMap = make(map[string] PersonInfo)创建并初始化map的代码如下：myMap = map[string] PersonInfo&#123; "1234": PersonInfo&#123;"1", "Jack", "Room 101,..."&#125;,&#125; 3.3元素赋值myMap[“1234”] = PersonInfo{“1”, “Jack”, “Room 101,…”} 3.4元素删除delete(myMap, “1234”) 3.5元素查找1234value, ok := myMap["1234"]if ok &#123; // 找到了 // 处理找到的value&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[+ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>First</tag>
      </tags>
  </entry>
</search>
