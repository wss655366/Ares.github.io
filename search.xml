<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang中的控制流程]]></title>
    <url>%2F2017%2F11%2F02%2Felse%2F</url>
    <content type="text"><![CDATA[+ 1.条件语句if是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行if后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。123if condition &#123; // do something&#125; 两个分支：12345 if condition &#123; // do something&#125; else &#123; // do something&#125; 多个分支：1234567if condition1 &#123; // do something&#125; else if condition2 &#123; // do something else&#125;else &#123; // catch-all or default&#125; 简单示例：12345678910package mainimport "fmt"func main() &#123; bool1 := true if bool1 &#123; fmt.Printf("The value is true\n") &#125; else &#123; fmt.Printf("The value is false\n") &#125;&#125; 关于条件语句，需要注意以下几点：  条件语句不需要使用括号将条件包含起来()； 无论语句体内有几条语句，花括号{}都是必须存在的； 左花括号{必须与if或者else处于同一行；  在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔；  在有返回值的函数中，不允许将“终的”return语句包含在if…else…结构中,否则会编译失败： function ends without a return statement。 失败的原因在于，Go编译器无法找到终止该函数的return语句。 1.1测试多返回值函数的错误习惯用法123456value, err := pack1.Function1(param1)if err != nil &#123; fmt.Printf("An error occured in pack1.Function1 with parameter %v", param1) return err&#125;// 未发生错误，继续执行： 如果在main函数中执行这段代码，程序会直接停止运行。如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数：1234if err != nil &#123; fmt.Printf("Program stopping with error %v", err) os.Exit(1)&#125; 2.switch结构用法：12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。简单示例：12345678910111213141516package mainimport "fmt"func main() &#123; var num1 int = 100 switch num1 &#123; case 98, 99: fmt.Println("It's equal to 98") case 100: fmt.Println("It's equal to 100") default: fmt.Println("It's not equal to 98 or 100") &#125;&#125; 3.for语句基本形式： 1for 初始化语句; 条件语句; 修饰语句 &#123;&#125; for 循环嵌套起来：12345for i:=0; i&lt;5; i++ &#123; for j:=0; j&lt;10; j++ &#123; println(j) &#125;&#125; 3.1基于条件判断的迭代123456789101112package mainimport "fmt"func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf("The variable i is now: %d\n", i) &#125;&#125; 3.2 for-range 结构12345678910111213package mainimport "fmt"func main() &#123; str := "Go is a beautiful language!" fmt.Printf("The length of str is: %d\n", len(str)) for pos, char := range str &#123; fmt.Printf("Character on position %d is: %c \n", pos, char) &#125; fmt.Println()&#125; 首先输出字符串的长度，然后通过for-range，遍历每个字符，然后分别输出每个字符。（通过键值对的组合） 4.Break和continuebreak会跳出当前的循环： 1234567for &#123; i = i - 1 fmt.Printf("The variable i is now: %d\n", i) if i &lt; 0 &#123; break &#125;&#125; 每次迭代都会对条件进行检查（i &lt; 0），以此判断是否需要停止循环。如果退出条件满足，则使用 break 语句退出循环。break 的作用范围是该循环的最内部循环体。 关键字continue忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件。 1234567891011package mainfunc main() &#123; for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; continue &#125; print(i) print(" ") &#125;&#125; 5.标签与gotofor、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母continue: 1234567891011121314151617package mainimport "fmt"func main() &#123;LABEL1: for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf("i is: %d, and j is: %d\n", i, j) &#125; &#125;&#125; continue语句指向LABEL1，当执行到该语句的时候，就会跳转到LABEL1标签的位置。当 j==4和j==5的时候，没有任何输出：标签的作用对象为外部循环。goto: 123456789101112package mainfunc main() &#123; i:=0 HERE: print(i) i++ if i==5 &#123; return &#125; goto HERE&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012 一个人也要生活的很精致]]></title>
    <url>%2F2017%2F11%2F02%2F12%2F</url>
    <content type="text"><![CDATA[+ 在我们的生命里，会遇到许多人，也会很成功的错过很多人，成为彼此生命中的过客，直到最后那个不离开的人，才会是我们生命中最重要的人。我想，总有一天，我们都会遇到那个对的人，在此之前，我们都应该让自己更加完美，以最美的姿态迎接那个对的人。 随手拍——图文无关 荷西问三毛：你想嫁个什么样的人？三毛说：看的顺眼的，千万富翁也嫁；看不顺眼的，亿万富翁也嫁。荷西：说来说去还是想嫁个有钱的。三毛看了荷西一眼：也有例外。那你要是嫁给我呢？荷西问道。三毛叹了口气：要是你的话，只要够吃饭的钱就够了。那你吃得多吗？荷西问。不多不多，以后还可以少吃点。我们都会遇到那么一个人，遇到之后，原来那些条条框框的标准，都会一条不剩，爱的仅仅是那个人，我们都会渴望柯西和三毛爱情，简简单单，一个眼神就足以读懂对方，希望我们都会尽早遇到那个人吧。 随手拍——图文无关 在这个陌生的城市中，希望我们不要迷失自己，一个人也要生活的很精致，没有遇到那个对的人之前，努力让自己更加完美一点。喜欢阅读，虽然不会立刻感觉都有多大用处，但是我相信，量变会引起质变的，这些都将是我的财富。偶尔周末出去走走，虽然说也没有什么收获，但也可以让自己散散心，以最好的状态面对新的一周，面对工作和学习。不要老是羡慕别人的生活，只要我们愿意付出，我们自己的生活也会充满诗情画意。无论你在哪，你在干什么，请务必记得，一个人也要生活的很精致！ 我在想你，你知道么？]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang实现简单的聊天室]]></title>
    <url>%2F2017%2F10%2F31%2Fchat%2F</url>
    <content type="text"><![CDATA[+ 首先，要实现聊天，就要有一个服务器接收发送到的信息，还有一个客户端向服务器发送信息，所以有两部分代码，一部分是客户端，另一部分是服务端。 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( "fmt" "net" "os")//通道var clients []net.Connfunc main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port data = make([]byte, 1024) ) fmt.Println("Initiating server...") lis, err := net.Listen("tcp", remote) defer lis.Close() if err != nil &#123; fmt.Printf("Error when listen: %s, Err: %s\n", remote, err) os.Exit(-1) &#125; for &#123; var res string conn, err := lis.Accept() if err != nil &#123; fmt.Println("Error accepting client: ", err.Error()) os.Exit(0) &#125; clients = append(clients, conn) go func(con net.Conn) &#123; fmt.Println("New connection: ", con.RemoteAddr()) // Get client's name length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %v quit.\n", con.RemoteAddr()) con.Close() disconnect(con, con.RemoteAddr().String()) return &#125; name := string(data[:length]) comeStr := name + " entered the room." notify(con, comeStr) // Begin recieve message from client for &#123; length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %s quit.\n", name) con.Close() disconnect(con, name) return &#125; res = string(data[:length]) sprdMsg := name + " said: " + res fmt.Println(sprdMsg) res = "You said:" + res con.Write([]byte(res)) notify(con, sprdMsg) &#125; &#125;(conn) &#125;&#125;//服务端收到消息后需要通知各个客户端func notify(conn net.Conn, msg string) &#123; for _, con := range clients &#123; if con.RemoteAddr() != conn.RemoteAddr() &#123; con.Write([]byte(msg)) &#125; &#125;&#125;//当有人离开聊天室时，通知所有的用户。func disconnect(conn net.Conn, name string) &#123; for index, con := range clients &#123; if con.RemoteAddr() == conn.RemoteAddr() &#123; disMsg := name + " has left the room." fmt.Println(disMsg) clients = append(clients[:index], clients[index+1:]...) notify(conn, disMsg) &#125; &#125;&#125; 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( "bufio" "fmt" "net" "os")var writeStr, readStr = make([]byte, 1024), make([]byte, 1024)func main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port reader = bufio.NewReader(os.Stdin) ) con, err := net.Dial("tcp", remote) defer con.Close() if err != nil &#123; fmt.Println("Server not found.") os.Exit(-1) &#125; fmt.Println("Connection OK.") fmt.Printf("Enter your name: ") fmt.Scanf("%s", &amp;writeStr) in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; fmt.Println("Now begin to talk!") go read(con) for &#123; writeStr, _, _ = reader.ReadLine() if string(writeStr) == "quit" &#123; fmt.Println("Communication terminated.") os.Exit(1) &#125; in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; &#125;&#125;func read(conn net.Conn) &#123; for &#123; length, err := conn.Read(readStr) if err != nil &#123; fmt.Printf("Error when read from server. Error:%s\n", err) os.Exit(0) &#125; fmt.Println(string(readStr[:length])) &#125;&#125; 结果见下图先开启服务端 然后开启服务端]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011 始于颜值 陷于才华 忠于人品]]></title>
    <url>%2F2017%2F10%2F31%2F011onlyyou%2F</url>
    <content type="text"><![CDATA[+ 始于心动，终于白首，初于花雨，至于天荒！ 每天，只有这个时候是最心静的，也只有这个时候是属于我自己的，或许我想什么，说什么你都不会知道吧，喜欢你，可是又不想打扰你，不想让你觉得我烦，很矛盾，不想错过你，又不想烦你，总是说顺其自然，但是又怕顺着顺着又没了， 不善于表达，或许会更难吧。 想说陪我走走吧，去哪都行，只要你愿意！想说带你去吃饭，你想吃什么我都给你做，新学的红烧排骨很不错，只要你愿意！想说聊聊天吧，虽然我看了好多套路却一套都没学会，只要你愿意！想说想你了，无论是忙还是闲。 虽然遇到一个自己喜欢和喜欢自己的人很难，但是总该争取的还是要好好争取，望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。希望我们还会再相遇吧！]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的数组]]></title>
    <url>%2F2017%2F10%2F30%2Farray%2F</url>
    <content type="text"><![CDATA[+ 1.数组1.1常见声明：1234[32]byte //长度32的字节数组[2*N] struct &#123;x, y int32&#125; //复杂类型的数组[1000]*float64 //指针数组[3][5]int //int类型的二维数组 1.2元素访问：通过数组下标访问元素。123for i: = 0; i &lt; len(array): i++ &#123;fmt.Println("Element",i,"of array is",array[i])&#125; Go语言还提供了一个关键字range，用于便捷地遍历容器中的元素。123for i, v := range array &#123; fmt.Println("Array element[", i, "]=", v)&#125; 1.3值类型在Go语言中数组是一个值类型，所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。 如果将数组作为函数的参数类型，则在函数调用时参数将发生复制。 1234567891011package mainimport "fmt"func modify(array [10]int) &#123; array[0] = 10 // 试图修改数组的第一个元素 fmt.Println("In modify(), array values:", array)&#125;func main() &#123; array := [5]int&#123;1,2,3,4,5&#125; // 定义并初始化一个数组 modify(array) // 传递给一个函数，并试图在函数体内修改这个数组内容 fmt.Println("In main(), array values:", array)&#125; 2.数组切片2.1创建数组切片123mySlice1 := make([]int, 5)mySlice2 := make([]int, 5, 10)mySlice3 := []int&#123;1, 2, 3, 4, 5&#125; 2.2元素遍历通过for循环：123for i := 0; i &lt;len(mySlice); i++ &#123; fmt.Println("mySlice[", i, "] =", mySlice[i])&#125; 使用range关键字遍历123for i, v := range mySlice &#123; fmt.Println("mySlice[", i, "] =", v)&#125; 2.3动态增加元素通过内置函数获取切片长度和容量1234567package mainimport "fmt"func main() &#123; mySlice := make([]int, 5, 10) fmt.Println("len(mySlice):", len(mySlice)) fmt.Println("cap(mySlice):", cap(mySlice))&#125; 通过append函数向数组切片中追加元素1234mySlice = append(mySlice, 1, 2, 3)mySlice2 := []int&#123;8, 9, 10&#125;// 给mySlice后面添加另一个数组切片mySlice = append(mySlice, mySlice2...) 2.4基于数组切片创建数组切片12oldSlice := []int&#123;1, 2, 3, 4, 5&#125;newSlice := oldSlice[:3] // 基于oldSlice的前3个元素构建新数组切片 2.5内容复制1234slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 2.6代码示例1234567891011121314151617package mainimport "fmt"func main() &#123; // 先定义一个数组 var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; // 基于数组创建一个数组切片 var mySlice []int = myArray[:5] fmt.Println("Elements of myArray: ") for _, v := range myArray &#123; fmt.Print(v, " ") &#125; fmt.Println("\nElements of mySlice: ") for _, v := range mySlice &#123; fmt.Print(v, " ") &#125; fmt.Println()&#125; 3.map3.1代码示例123456789101112131415161718192021222324package mainimport "fmt"// PersonInfo是一个包含个人详细信息的类型type PersonInfo struct &#123; ID string Name string Address string&#125;func main() &#123;var personDB map[string] PersonInfo personDB = make(map[string] PersonInfo) // 往这个map里插入几条数据 personDB["12345"] = PersonInfo&#123;"12345", "Tom", "Room 203,..."&#125; personDB["1"] = PersonInfo&#123;"1", "Jack", "Room 101,..."&#125; // 从这个map查找键为"1234"的信息 person, ok := personDB["1234"] // ok是一个返回的bool型，返回true表示找到了对应的数据 if ok &#123; fmt.Println("Found person", person.Name, "with ID 1234.") &#125; else &#123; fmt.Println("Did not find person with ID 1234.") &#125;&#125; 3.2变量声明var myMap map[string] PersonInfo 3.3创建123456// PersonInfohi一个结构体myMap = make(map[string] PersonInfo)创建并初始化map的代码如下：myMap = map[string] PersonInfo&#123; "1234": PersonInfo&#123;"1", "Jack", "Room 101,..."&#125;,&#125; 3.3元素赋值myMap[“1234”] = PersonInfo{“1”, “Jack”, “Room 101,…”} 3.4元素删除delete(myMap, “1234”) 3.5元素查找1234value, ok := myMap["1234"]if ok &#123; // 找到了 // 处理找到的value&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[+ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>First</tag>
      </tags>
  </entry>
</search>
