<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[012 一个人也要生活的很精致]]></title>
    <url>%2F2017%2F11%2F02%2F12%2F</url>
    <content type="text"><![CDATA[+ 在我们的生命里，会遇到许多人，也会很成功的错过很多人，成为彼此生命中的过客，直到最后那个不离开的人，才会是我们生命中最重要的人。我想，总有一天，我们都会遇到那个对的人，在此之前，我们都应该让自己更加完美，以最美的姿态迎接那个对的人。 随手拍——图文无关 荷西问三毛：你想嫁个什么样的人？三毛说：看的顺眼的，千万富翁也嫁；看不顺眼的，亿万富翁也嫁。荷西：说来说去还是想嫁个有钱的。三毛看了荷西一眼：也有例外。那你要是嫁给我呢？荷西问道。三毛叹了口气：要是你的话，只要够吃饭的钱就够了。那你吃得多吗？荷西问。不多不多，以后还可以少吃点。我们都会遇到那么一个人，遇到之后，原来那些条条框框的标准，都会一条不剩，爱的仅仅是那个人，我们都会渴望柯西和三毛爱情，简简单单，一个眼神就足以读懂对方，希望我们都会尽早遇到那个人吧。 随手拍——图文无关 在这个陌生的城市中，希望我们不要迷失自己，一个人也要生活的很精致，没有遇到那个对的人之前，努力让自己更加完美一点。喜欢阅读，虽然不会立刻感觉都有多大用处，但是我相信，量变会引起质变的，这些都将是我的财富。偶尔周末出去走走，虽然说也没有什么收获，但也可以让自己散散心，以最好的状态面对新的一周，面对工作和学习。不要老是羡慕别人的生活，只要我们愿意付出，我们自己的生活也会充满诗情画意。无论你在哪，你在干什么，请务必记得，一个人也要生活的很精致！ 我在想你，你知道么？]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang实现简单的聊天室]]></title>
    <url>%2F2017%2F10%2F31%2Fchat%2F</url>
    <content type="text"><![CDATA[+ 首先，要实现聊天，就要有一个服务器接收发送到的信息，还有一个客户端向服务器发送信息，所以有两部分代码，一部分是客户端，另一部分是服务端。 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( "fmt" "net" "os")//通道var clients []net.Connfunc main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port data = make([]byte, 1024) ) fmt.Println("Initiating server...") lis, err := net.Listen("tcp", remote) defer lis.Close() if err != nil &#123; fmt.Printf("Error when listen: %s, Err: %s\n", remote, err) os.Exit(-1) &#125; for &#123; var res string conn, err := lis.Accept() if err != nil &#123; fmt.Println("Error accepting client: ", err.Error()) os.Exit(0) &#125; clients = append(clients, conn) go func(con net.Conn) &#123; fmt.Println("New connection: ", con.RemoteAddr()) // Get client's name length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %v quit.\n", con.RemoteAddr()) con.Close() disconnect(con, con.RemoteAddr().String()) return &#125; name := string(data[:length]) comeStr := name + " entered the room." notify(con, comeStr) // Begin recieve message from client for &#123; length, err := con.Read(data) if err != nil &#123; fmt.Printf("Client %s quit.\n", name) con.Close() disconnect(con, name) return &#125; res = string(data[:length]) sprdMsg := name + " said: " + res fmt.Println(sprdMsg) res = "You said:" + res con.Write([]byte(res)) notify(con, sprdMsg) &#125; &#125;(conn) &#125;&#125;//服务端收到消息后需要通知各个客户端func notify(conn net.Conn, msg string) &#123; for _, con := range clients &#123; if con.RemoteAddr() != conn.RemoteAddr() &#123; con.Write([]byte(msg)) &#125; &#125;&#125;//当有人离开聊天室时，通知所有的用户。func disconnect(conn net.Conn, name string) &#123; for index, con := range clients &#123; if con.RemoteAddr() == conn.RemoteAddr() &#123; disMsg := name + " has left the room." fmt.Println(disMsg) clients = append(clients[:index], clients[index+1:]...) notify(conn, disMsg) &#125; &#125;&#125; 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( "bufio" "fmt" "net" "os")var writeStr, readStr = make([]byte, 1024), make([]byte, 1024)func main() &#123; var ( host = "localhost" port = "8000" remote = host + ":" + port reader = bufio.NewReader(os.Stdin) ) con, err := net.Dial("tcp", remote) defer con.Close() if err != nil &#123; fmt.Println("Server not found.") os.Exit(-1) &#125; fmt.Println("Connection OK.") fmt.Printf("Enter your name: ") fmt.Scanf("%s", &amp;writeStr) in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; fmt.Println("Now begin to talk!") go read(con) for &#123; writeStr, _, _ = reader.ReadLine() if string(writeStr) == "quit" &#123; fmt.Println("Communication terminated.") os.Exit(1) &#125; in, err := con.Write([]byte(writeStr)) if err != nil &#123; fmt.Printf("Error when send to server: %d\n", in) os.Exit(0) &#125; &#125;&#125;func read(conn net.Conn) &#123; for &#123; length, err := conn.Read(readStr) if err != nil &#123; fmt.Printf("Error when read from server. Error:%s\n", err) os.Exit(0) &#125; fmt.Println(string(readStr[:length])) &#125;&#125; 结果见下图先开启服务端 然后开启服务端]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011 始于颜值 陷于才华 忠于人品]]></title>
    <url>%2F2017%2F10%2F31%2F011onlyyou%2F</url>
    <content type="text"><![CDATA[+ 始于心动，终于白首，初于花雨，至于天荒！ 每天，只有这个时候是最心静的，也只有这个时候是属于我自己的，或许我想什么，说什么你都不会知道吧，喜欢你，可是又不想打扰你，不想让你觉得我烦，很矛盾，不想错过你，又不想烦你，总是说顺其自然，但是又怕顺着顺着又没了， 不善于表达，或许会更难吧。 想说陪我走走吧，去哪都行，只要你愿意！想说带你去吃饭，你想吃什么我都给你做，新学的红烧排骨很不错，只要你愿意！想说聊聊天吧，虽然我看了好多套路却一套都没学会，只要你愿意！想说想你了，无论是忙还是闲。 虽然遇到一个自己喜欢和喜欢自己的人很难，但是总该争取的还是要好好争取，望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。希望我们还会再相遇吧！]]></content>
      <categories>
        <category>异度空间</category>
      </categories>
      <tags>
        <tag>Encounter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang中的数组]]></title>
    <url>%2F2017%2F10%2F30%2Farray%2F</url>
    <content type="text"><![CDATA[+ 1.数组1.1常见声明：1234[32]byte //长度32的字节数组[2*N] struct &#123;x, y int32&#125; //复杂类型的数组[1000]*float64 //指针数组[3][5]int //int类型的二维数组 1.2元素访问：通过数组下标访问元素。123for i: = 0; i &lt; len(array): i++ &#123;fmt.Println("Element",i,"of array is",array[i])&#125; Go语言还提供了一个关键字range，用于便捷地遍历容器中的元素。123for i, v := range array &#123; fmt.Println("Array element[", i, "]=", v)&#125; 1.3值类型在Go语言中数组是一个值类型，所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。 如果将数组作为函数的参数类型，则在函数调用时参数将发生复制。 1234567891011package mainimport "fmt"func modify(array [10]int) &#123; array[0] = 10 // 试图修改数组的第一个元素 fmt.Println("In modify(), array values:", array)&#125;func main() &#123; array := [5]int&#123;1,2,3,4,5&#125; // 定义并初始化一个数组 modify(array) // 传递给一个函数，并试图在函数体内修改这个数组内容 fmt.Println("In main(), array values:", array)&#125; 2.数组切片2.1创建数组切片123mySlice1 := make([]int, 5)mySlice2 := make([]int, 5, 10)mySlice3 := []int&#123;1, 2, 3, 4, 5&#125; 2.2元素遍历通过for循环：123for i := 0; i &lt;len(mySlice); i++ &#123; fmt.Println("mySlice[", i, "] =", mySlice[i])&#125; 使用range关键字遍历123for i, v := range mySlice &#123; fmt.Println("mySlice[", i, "] =", v)&#125; 2.3动态增加元素通过内置函数获取切片长度和容量1234567package mainimport "fmt"func main() &#123; mySlice := make([]int, 5, 10) fmt.Println("len(mySlice):", len(mySlice)) fmt.Println("cap(mySlice):", cap(mySlice))&#125; 通过append函数向数组切片中追加元素1234mySlice = append(mySlice, 1, 2, 3)mySlice2 := []int&#123;8, 9, 10&#125;// 给mySlice后面添加另一个数组切片mySlice = append(mySlice, mySlice2...) 2.4基于数组切片创建数组切片12oldSlice := []int&#123;1, 2, 3, 4, 5&#125;newSlice := oldSlice[:3] // 基于oldSlice的前3个元素构建新数组切片 2.5内容复制1234slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 2.6代码示例1234567891011121314151617package mainimport "fmt"func main() &#123; // 先定义一个数组 var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; // 基于数组创建一个数组切片 var mySlice []int = myArray[:5] fmt.Println("Elements of myArray: ") for _, v := range myArray &#123; fmt.Print(v, " ") &#125; fmt.Println("\nElements of mySlice: ") for _, v := range mySlice &#123; fmt.Print(v, " ") &#125; fmt.Println()&#125; 3.map3.1代码示例123456789101112131415161718192021222324package mainimport "fmt"// PersonInfo是一个包含个人详细信息的类型type PersonInfo struct &#123; ID string Name string Address string&#125;func main() &#123;var personDB map[string] PersonInfo personDB = make(map[string] PersonInfo) // 往这个map里插入几条数据 personDB["12345"] = PersonInfo&#123;"12345", "Tom", "Room 203,..."&#125; personDB["1"] = PersonInfo&#123;"1", "Jack", "Room 101,..."&#125; // 从这个map查找键为"1234"的信息 person, ok := personDB["1234"] // ok是一个返回的bool型，返回true表示找到了对应的数据 if ok &#123; fmt.Println("Found person", person.Name, "with ID 1234.") &#125; else &#123; fmt.Println("Did not find person with ID 1234.") &#125;&#125; 3.2变量声明var myMap map[string] PersonInfo 3.3创建123456// PersonInfohi一个结构体myMap = make(map[string] PersonInfo)创建并初始化map的代码如下：myMap = map[string] PersonInfo&#123; "1234": PersonInfo&#123;"1", "Jack", "Room 101,..."&#125;,&#125; 3.3元素赋值myMap[“1234”] = PersonInfo{“1”, “Jack”, “Room 101,…”} 3.4元素删除delete(myMap, “1234”) 3.5元素查找1234value, ok := myMap["1234"]if ok &#123; // 找到了 // 处理找到的value&#125;]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[+ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>First</tag>
      </tags>
  </entry>
</search>
